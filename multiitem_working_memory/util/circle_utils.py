##Â SEE ALSO circle_utils_parallel !
from torch import Tensor as _T
import numpy as np
import torch
from math import pi, floor
from random import random


def polar2cart(rs, thetas):
    x = rs * np.cos(thetas)
    y = rs * np.sin(thetas)
    return x, y

def rectify_angles(x, scale_lower=-np.pi, scale_upper=np.pi) -> _T:
    if isinstance(x, _T) and x.names is not None:
        names = x.names
        x = x.rename(None)
    x = (x + np.pi) % (2 * np.pi) - np.pi
    scale_ratio = (scale_upper - scale_lower) / (2 * np.pi)
    ret = (x + np.pi + scale_lower) * scale_ratio
    if isinstance(x, _T):
        ret = ret.rename(*names)
    return ret

def norm_points(*points):
    normed_points = [p % (2 * pi) for p in points]
    return normed_points if len(normed_points) > 1 else normed_points[0]

def make_continuous_interval_cumsums(interval_list):
    cumulative_sums = [0]
    interval_list = [norm_points(*inte) for inte in interval_list]
    for j, il in enumerate(interval_list):
        if j > 0:
            assert il[0] > interval_list[j-1][1]
        elif j < len(interval_list) - 1:
            assert il[1] < interval_list[j+1][0]
        cumulative_sums.append(cumulative_sums[-1] + il[1] - il[0])
    return np.array(cumulative_sums[1:])


def make_interval_circular(ccw, cw):
    # Wraps a clockwise-turning interval around a circle, assuming it is less than 2*pi itself
    if (ccw >= 2 * pi) or (cw >= 2 * pi):
        return make_interval_circular(ccw % (2 * pi), cw % (2 * pi))
    if (ccw <= - pi) or (cw <= - pi):
        return make_interval_circular(ccw + 2 * pi, cw + 2 * pi)
    if ccw >= cw:
        return [ccw - 2 * pi, cw]
    return [ccw, cw]


def point_on_circle_contained(point, interval):
    # Assumes interval generated by make_interval_circular, as it was done from the start in generate_circular_feature_list
    normed_interval = norm_points(*interval)
    normed_point = norm_points(point)
    if normed_interval[1] >= normed_interval[0]:
        return (normed_point >= normed_interval[0]) and (normed_point <= normed_interval[1])
    else:
        return (normed_point >= normed_interval[0]) or (normed_point <= normed_interval[1])


def circular_interval_remove(existing_interval, removed_interval):
    # returns existing_interval \ removed_interval on the 2pi circle
    # interval goes clockwise from x_interval[0] to x_interval[1]
    # Assumes both intervals generated by make_interval_circular, as it was done from the start in generate_circular_feature_list

    # Four cases:
        # 1: removed_interval does not intersect with existing_interval     -> return [existing_interval]
        # 2: removed_interval `sits inside` existing_interval               -> return two intervals
        # 3: removed_interval encloses one boundary of existing_interval    -> return one interval
        # 4: removed_interval completely covers existing_interval           -> return []
        # 5: removed_interval "reflexively" covers both boundarie           -> return one interval
    # Case 5 is very rare, should only happen in the first case!
    
    # Sort cases by checking edges of existing_interval:
        # ccw_covered = ccw edge ([0]) of existing_interval covered by removed_interval
        # cw_covered = cw edge ([1]) of existing_interval covered by removed_interval
        # If ccw_covered and cw_covered 
            # Now do the reverse test (check boundaries of removed_interval) to differentiate
            # Assert that either both are true or both are false!
                # If both false -> case 4
                # If both true -> case 5
        # If (not ccw_covered) and (not cw_covered) -> case 1 or 2
            # Now do the reverse test (check boundaries of removed_interval) to differentiate
        # If (ccw_covered xor cw_covered) -> case 3

    existing_interval = make_interval_circular(*existing_interval)

    ccw_covered = point_on_circle_contained(existing_interval[0], removed_interval)
    cw_covered = point_on_circle_contained(existing_interval[1], removed_interval)

    if ccw_covered and cw_covered:

        inverse_ccw_covered = point_on_circle_contained(removed_interval[0], existing_interval)
        inverse_cw_covered = point_on_circle_contained(removed_interval[1], existing_interval)

        if (not inverse_ccw_covered) and (not inverse_ccw_covered):
            intervals = []                                                      # case 4
        elif inverse_ccw_covered and inverse_ccw_covered:
            intervals = [[removed_interval[1], removed_interval[0]]]            # case 5
        else:
            raise Exception

    elif (not ccw_covered) and (not cw_covered):

        inverse_ccw_covered = point_on_circle_contained(removed_interval[0], existing_interval)
        inverse_cw_covered = point_on_circle_contained(removed_interval[1], existing_interval)

        if inverse_ccw_covered and inverse_cw_covered:  # removed interval sits in the middle of the existing one
            intervals = [
                [existing_interval[0], removed_interval[0]],
                [removed_interval[1], existing_interval[1]]
            ]                                                               # case 2
        elif (not inverse_ccw_covered) and (not inverse_cw_covered):
            intervals = [existing_interval]                                 # case 1
        else:
            raise Exception('somethings gone wrong here')

    elif ccw_covered and (not cw_covered):
        intervals = [[removed_interval[1], existing_interval[1]]]           # case 3a

    elif (not ccw_covered) and cw_covered:
        intervals = [[existing_interval[0], removed_interval[0]]]           # case 3b

    return [make_interval_circular(*inte) for inte in intervals]


def generate_circular_feature_list(num_stim, feature_border, existing_features = []):
    # Generate num_stim features around a 2pi circle, with each element having feature_border on either side
    # Of course, if num_stim * 2 * feature_border >= 2 * pi then this throws an error because that's impossible
    # Algorithm:
        # Start with 
            # real_estate = ( [0, 2*pi] ,) i.e. a tuple of continuous intervals on the 2pi circle
            # continuous_real_estate = [0, 2*pi] which will be continuously updated as real_estate made continuous on R
            # features = []
        # While len(features) < num_stim:
            # u = random ( continuous_real_estate )
            # chosen_interval = ci s.t. sum(|real_estate[:ci]|) < u  i.e. the interval in real_estate that u 'lands in'
            # new_feature = real_estate[ci].lower + u - sum(|real_estate[:ci]|)
            # features.append(new_feature)
            # real_estate = [ re \ [new_feature - feature_border, new_feature + feature_border] ]
                # NB: removal (\) here done on the 2pi circle
            # continuous_real_estate = [0, sum_i( | real_estate[i] | )]
        # Return features

    if num_stim * 2 * feature_border >= 2 * pi:
        max_stim = np.floor(pi / feature_border)
        raise ValueError(f'Cannot create a circle with {num_stim} features if each feature requires {feature_border} space on each side. Maximum is {max_stim}')

    features = []
    real_estate = [[0, 2 * pi - 1e-7]]

    # save some time
    if feature_border == 0.0:
        return [(random() * 2 * pi) for _ in range(num_stim)]

    assert len(existing_features) <= num_stim

    while len(features) < num_stim:

        if len(features) < len(existing_features):
            new_feature = existing_features[len(features)]
            features.append(new_feature)

        else:
            cumulative_sums = make_continuous_interval_cumsums(real_estate)
            u = random() * cumulative_sums[-1]  # i.e. cumulative_sums[-1] is continuous_real_estate above
            ci = sum(cumulative_sums < u)   # XXX: might need a -1 here?
            new_feature = real_estate[ci][0] + u - (cumulative_sums[ci-1] if ci > 0 else 0.0)
            features.append(new_feature)

        new_real_estate = []
        unavailable_interval = make_interval_circular(new_feature - feature_border, new_feature + feature_border)
        for re in real_estate:  # should really apply make_interval_circular to re too, but this is the assumed case...
            new_real_estate.extend(circular_interval_remove(re, unavailable_interval))
        real_estate = new_real_estate

        # print("features:\t", features, '\n')
        # print("unavailable_interval:\t", unavailable_interval, '\n')
        # print("real_estate:\t", real_estate, '\n')

    # np_features = np.array(features)
    # if not all((np.abs(rectify_angles(np_features - np_features.reshape(-1, 1))))[np.triu_indices(len(features), 1)] > feature_border):
    #     raise Exception

    # if np.array(real_estate).min() < 0:
    #     np.array(real_estate) % (2*pi)
    #     import pdb; pdb.set_trace()

    return features# , real_estate


def rot_to_rgb(rot, s=1, v=1, scale_255 = False, nan_replacement = (0,0,0)):
        h = rot / pi * 180
        s = float(s)
        v = float(v)
        h60 = h / 60.0
        try:
            h60f = floor(h60)
        except:
            assert np.isnan(h60)
            return nan_replacement # show up as black!
        hi = int(h60f) % 6
        f = h60 - h60f
        p = v * (1 - s)
        q = v * (1 - f * s)
        t = v * (1 - (1 - f) * s)
        r, g, b = 0, 0, 0
        if hi == 0: r, g, b = v, t, p
        elif hi == 1: r, g, b = q, v, p
        elif hi == 2: r, g, b = p, v, t
        elif hi == 3: r, g, b = p, q, v
        elif hi == 4: r, g, b = t, p, v
        elif hi == 5: r, g, b = v, p, q
        if scale_255:
            r, g, b = int(r * 255), int(g * 255), int(b * 255)
        return tuple(float(x) for x in (r, g, b))


def rot_to_rgb_torch(rot: _T, nan_replacement = (0.,0.,0.)):
    h = rot / pi * 180
    h60 = h / 60.0
    h60f = torch.floor(h60)
    canvas = torch.zeros(*rot.shape, 3)
    hi = h60f.int() % 6
    f = h60 - h60f
    q = (1.0 - f)
    t = f
    p = torch.zeros_like(t)
    v = torch.ones_like(t)
    canvas[hi == 0] = torch.stack([v, t, p], -1)[hi == 0]
    canvas[hi == 1] = torch.stack([q, v, p], -1)[hi == 1]
    canvas[hi == 2] = torch.stack([p, v, t], -1)[hi == 2]
    canvas[hi == 3] = torch.stack([p, q, v], -1)[hi == 3]
    canvas[hi == 4] = torch.stack([t, p, v], -1)[hi == 4]
    canvas[hi == 5] = torch.stack([v, p, q], -1)[hi == 5]
    canvas[h60.isnan()] = torch.tensor(nan_replacement)
    return canvas

