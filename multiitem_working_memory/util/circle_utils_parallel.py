## Gibbs sampling requires many spaced out multiorientation displays to be generated
## rapidally with interdependence. Looping over batch items and chains doesn't cut it,
## so we need to parallelise everything. We will do this in numpy to keep things simple

import numpy as np
from math import pi
from numpy import ndarray as A


def norm_points(*points: A):
    return tuple(p % (2 * pi) for p in points)


def make_continuous_interval_cumsums(interval_starts: A, interval_ends: A):
    """
    Expecting both arrays in shape [batch, num_intervals] i.e. interval_starts[b,i]
        gives you the start angle of the ith interval for the bth display
    """
    normed_interval_ends, normed_interval_starts = norm_points(interval_ends, interval_starts)
    interval_sizes = (normed_interval_ends - normed_interval_starts)
    # assert (interval_sizes >= 0.0).all()
    # assert (normed_interval_starts[:,1:] >= normed_interval_ends[:,:-1]).all()
    interval_cumsums = interval_sizes.cumsum(axis = 1)
    return interval_cumsums


def make_interval_circular(ccw_points, cw_points):
    """
    Wraps a clockwise-turning interval around a circle, assuming it is less than 2*pi itself
    Flexible to shapes, but expects [batch, num_intervals] for both arguments
    """
    ccw_points, cw_points = ccw_points.copy(), cw_points.copy()
    if ccw_points.size == 0:
        return 0.0, 0.0 # Won't make a change anyway

    modulo_flag: A = np.logical_or((ccw_points >= 2 * pi), (cw_points >= 2 * pi))
    ccw_points[modulo_flag], cw_points[modulo_flag] = make_interval_circular(ccw_points[modulo_flag] % (2 * pi), cw_points[modulo_flag] % (2 * pi))

    shiftup_flag: A = np.logical_or((ccw_points <= -pi), (cw_points <= -pi))
    shiftup_flag: A = np.logical_and(shiftup_flag, ~modulo_flag)
    ccw_points[shiftup_flag], cw_points[shiftup_flag] = make_interval_circular(ccw_points[shiftup_flag] + (2 * pi), cw_points[shiftup_flag] + (2 * pi))

    wrong_order_flag: A = (ccw_points >= cw_points)
    wrong_order_flag: A = np.logical_and(wrong_order_flag, ~(shiftup_flag | modulo_flag))
    ccw_points[wrong_order_flag] = ccw_points[wrong_order_flag] - 2 * pi

    return ccw_points, cw_points


def point_on_circle_contained(points: A, interval_ccw: A, interval_cw: A):
    """
    Assumes interval generated by make_interval_circular, as it was done from the start in generate_circular_feature_list
    Flexible to shapes, but expects [batch, num_intervals/num_points] for both arguments

    Returns a boolean array of the same shape telling you which points are contained
    """
    normed_points, normed_interval_ccw, normed_interval_cw = norm_points(points, interval_ccw, interval_cw)

    output = np.zeros_like(normed_points).astype(bool)
    ordered_flag = (normed_interval_cw >= normed_interval_ccw)

    output[ordered_flag]: A = np.logical_and((normed_points >= normed_interval_ccw), (normed_points <= normed_interval_cw))[ordered_flag]
    output[~ordered_flag]: A = np.logical_or((normed_points >= normed_interval_ccw), (normed_points <= normed_interval_cw))[~ordered_flag]

    return output


def circular_interval_remove(existing_interval_ccw, existing_interval_cw, removed_interval_ccw, removed_interval_cw):
    """
    Returns existing_interval \ removed_interval on the 2pi circle
    Assumes both intervals generated by make_interval_circular, as it was done from the start in generate_circular_feature_list

    See comment below for implementation, taken from the original, non-parallelised case

    Expects [batch, 1] for all arguments

    Key difference here:
        Every case will return two intervals, which will be slotted in as required (see new implementation of generate_circular_feature_list)
        These two intervals will be given in as two arrays of size [batch, 2] each, with the intervals in order in the last dimensions
            (Again, yet to test the case where arguments come in with more dimensions)
    """
    # Four cases:
        # 1: removed_interval does not intersect with existing_interval     -> return [existing_interval]
        # 2: removed_interval `sits inside` existing_interval               -> return two intervals
        # 3: removed_interval encloses one boundary of existing_interval    -> return one interval
        # 4: removed_interval completely covers existing_interval           -> return []
        # 5: removed_interval "reflexively" covers both boundarie           -> return one interval
    # Case 5 is very rare, should only happen in the first case!
    
    # Sort cases by checking edges of existing_interval:
        # ccw_covered = ccw edge ([0]) of existing_interval covered by removed_interval
        # cw_covered = cw edge ([1]) of existing_interval covered by removed_interval
        # If ccw_covered and cw_covered 
            # Now do the reverse test (check boundaries of removed_interval) to differentiate
            # Assert that either both are true or both are false!
                # If both false -> case 4
                # If both true -> case 5
        # If (not ccw_covered) and (not cw_covered) -> case 1 or 2
            # Now do the reverse test (check boundaries of removed_interval) to differentiate
        # If (ccw_covered xor cw_covered) -> case 3

    batch_size, asdf = existing_interval_ccw.shape
    assert asdf == 1
    
    existing_interval_ccw, existing_interval_cw = make_interval_circular(existing_interval_ccw, existing_interval_cw)

    ccw_covered = point_on_circle_contained(existing_interval_ccw, removed_interval_ccw, removed_interval_cw)
    cw_covered = point_on_circle_contained(existing_interval_cw, removed_interval_ccw, removed_interval_cw)

    inverse_ccw_covered = point_on_circle_contained(removed_interval_ccw, existing_interval_ccw, existing_interval_cw)
    inverse_cw_covered = point_on_circle_contained(removed_interval_cw, existing_interval_ccw, existing_interval_cw)

    flag_4_or_5: A = np.logical_and(ccw_covered, cw_covered)
    flag_4_checker: A = np.logical_and(~inverse_ccw_covered, ~inverse_cw_covered)
    flag_5_checker: A = np.logical_and(inverse_ccw_covered, inverse_cw_covered)
    # assert np.logical_xor(flag_4_checker[flag_4_or_5], flag_5_checker[flag_4_or_5]).all()
    flag_4: A = np.logical_and(flag_4_or_5, flag_4_checker).flatten()
    flag_5: A = np.logical_and(flag_4_or_5, flag_5_checker).flatten()

    flag_1_or_2: A = np.logical_and(~ccw_covered, ~cw_covered)
    flag_1: A = np.logical_and(flag_1_or_2, flag_4_checker).flatten() # Nice and versatile
    flag_2: A = np.logical_and(flag_1_or_2, flag_5_checker).flatten()

    flag_3a: A = np.logical_and(ccw_covered, ~cw_covered).flatten()
    flag_3b: A = np.logical_and(~ccw_covered, cw_covered).flatten()

    # assert (flag_1 | flag_2 | flag_3a | flag_3b | flag_4 | flag_5).mean() == 1.0
    # assert (flag_1 & flag_2 & flag_3a & flag_3b & flag_4 & flag_5).mean() == 0.0

    new_intervals_ccw, new_intervals_cw = np.zeros([batch_size, 1, 2]), np.zeros([batch_size, 1, 2])

    # Case 1 - one replicated interval and one empty interval
    new_intervals_ccw[flag_1, :, 0] = existing_interval_ccw[flag_1]
    new_intervals_cw[flag_1, :, 0] = existing_interval_cw[flag_1]
    new_intervals_ccw[flag_1, :, 1] = existing_interval_cw[flag_1]
    new_intervals_cw[flag_1, :, 1] = existing_interval_cw[flag_1]

    # Case 2 - two distinct new intervals
    new_intervals_ccw[flag_2, :, 0] = existing_interval_ccw[flag_2]
    new_intervals_cw[flag_2, :, 0] = removed_interval_ccw[flag_2]
    new_intervals_ccw[flag_2, :, 1] = removed_interval_cw[flag_2]
    new_intervals_cw[flag_2, :, 1] = existing_interval_cw[flag_2]

    # Case 3a and 3b - one cut interval and one empty interval
    new_intervals_ccw[flag_3a, :, 0] = removed_interval_cw[flag_3a]
    new_intervals_cw[flag_3a, :, 0] = existing_interval_cw[flag_3a]
    new_intervals_ccw[flag_3a, :, 1] = existing_interval_cw[flag_3a]
    new_intervals_cw[flag_3a, :, 1] = existing_interval_cw[flag_3a]

    new_intervals_ccw[flag_3b, :, 0] = existing_interval_ccw[flag_3b]
    new_intervals_cw[flag_3b, :, 0] = removed_interval_ccw[flag_3b]
    new_intervals_ccw[flag_3b, :, 1] = removed_interval_ccw[flag_3b]
    new_intervals_cw[flag_3b, :, 1] = removed_interval_ccw[flag_3b]

    # Case 4 - two empty intervals
    new_intervals_ccw[flag_4, :, 0] = existing_interval_ccw[flag_4]
    new_intervals_cw[flag_4, :, 0] = existing_interval_ccw[flag_4]
    new_intervals_ccw[flag_4, :, 1] = existing_interval_cw[flag_4]
    new_intervals_cw[flag_4, :, 1] = existing_interval_cw[flag_4]

    # Case 5 - one `reflexive' interval and one empty interval
    new_intervals_ccw[flag_5, :, 0] = removed_interval_cw[flag_5]
    new_intervals_cw[flag_5, :, 0] = removed_interval_ccw[flag_5]
    new_intervals_ccw[flag_5, :, 1] = removed_interval_ccw[flag_5]
    new_intervals_cw[flag_5, :, 1] = removed_interval_ccw[flag_5]

    # return make_interval_circular(new_intervals_ccw, new_intervals_cw)
    return new_intervals_ccw, new_intervals_cw




def generate_circular_feature_list(batch_size, num_stim, feature_border, existing_features: A = None):
    """
    Outputs an array of shape [batch_size, num_stim]
    Expects existing_features (if given) of size [batch_size, num_existing_stim], where num_existing_stim
        is expected to be the same for all batch members

    See comment below for (old) implementation details, based on the non-parallelised version

    For parallelisation:
        real_estate is now two arrays, each of shape [batch_size, num_intervals], giving the ccw and cw points
            of these intervals. num_intervals is the same for all batch members because circular_interval_remove
            always outputs two intervals
    """
    # Generate num_stim features around a 2pi circle, with each element having feature_border on either side
    # Of course, if num_stim * 2 * feature_border >= 2 * pi then this throws an error because that's impossible
    # Algorithm:
        # Start with 
            # real_estate = ( [0, 2*pi] ,) i.e. a tuple of continuous intervals on the 2pi circle
            # continuous_real_estate = [0, 2*pi] which will be continuously updated as real_estate made continuous on R
            # features = []
        # While len(features) < num_stim:
            # u = random ( continuous_real_estate )
            # chosen_interval = ci s.t. sum(|real_estate[:ci]|) < u  i.e. the interval in real_estate that u 'lands in'
            # new_feature = real_estate[ci].lower + u - sum(|real_estate[:ci]|)
            # features.append(new_feature)
            # real_estate = [ re \ [new_feature - feature_border, new_feature + feature_border] ]
                # NB: removal (\) here done on the 2pi circle
            # continuous_real_estate = [0, sum_i( | real_estate[i] | )]
        # Return features

    if num_stim * 2 * feature_border >= 2 * pi:
        raise ValueError(f'Cannot create a circle with {num_stim} features if each feature requires {feature_border} space on each side')

    real_estate_ccw = np.zeros([batch_size, 1])
    real_estate_cw = np.ones([batch_size, 1]) * (2 * pi - 1e-7)

    # save some time
    if feature_border == 0.0:
        return np.random.rand(batch_size, num_stim) * 2 * pi

    if existing_features is None:
        existing_features = np.zeros([batch_size, 0])
    assert existing_features.shape[-1] <= num_stim

    features_done = 0
    features = np.zeros([batch_size, num_stim])

    while features_done < num_stim:
        
        if features_done < existing_features.shape[-1]:
            new_feature = existing_features[:, [features_done]]
            features[:, features_done] = new_feature[:,0]

        else:
            cumulative_sums = make_continuous_interval_cumsums(real_estate_ccw, real_estate_cw)
            u = np.random.rand(batch_size, 1) * cumulative_sums[:,[-1]]
            ci = (cumulative_sums < u).sum(-1, keepdims=True)
            
            interval_start = np.take_along_axis(real_estate_ccw, ci, 1)   # Same as "real_estate[ci][0]" before
            removal = np.take_along_axis(cumulative_sums, ci-1, 1)
            removal[ci == 0] = 0.0  # Same as "(cumulative_sums[:,ci-1] if ci > 0 else 0.0)" before
            
            new_feature = interval_start + u - removal
            features[:, features_done] = new_feature[:, 0]

        unavailable_interval_ccw, unavailable_interval_cw = make_interval_circular(
            new_feature - feature_border, new_feature + feature_border
        )
        
        new_real_estate_ccw = np.zeros((batch_size, 2 * real_estate_ccw.shape[-1]))   # number of intervals always doubles
        new_real_estate_cw = np.zeros((batch_size, 2 * real_estate_cw.shape[-1]))     # number of intervals always doubles
        for i in range(real_estate_ccw.shape[-1]):
            re_ccw, re_cw = real_estate_ccw[:,[i]], real_estate_cw[:,[i]]
            new_intervals_ccw, new_intervals_cw = circular_interval_remove(
                re_ccw, re_cw, unavailable_interval_ccw, unavailable_interval_cw
            )
            new_real_estate_ccw[:,2*i:2*(i+1)] = new_intervals_ccw[:,0,:]
            new_real_estate_cw[:,2*i:2*(i+1)] = new_intervals_cw[:,0,:]
            
        real_estate_ccw, real_estate_cw = new_real_estate_ccw, new_real_estate_cw

        features_done += 1

    # unsqueezed_features = features[:,:,None]
    # diffs = np.abs(rectify_angles(unsqueezed_features - unsqueezed_features.swapaxes(1, 2)))
    # r,c = np.triu_indices(num_stim, 1)
    # assert diffs[:,r,c].min() >= feature_border

    return features




